package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"

	"github.com/onion0904/CarShareSystem/app/config"
	errDomain "github.com/onion0904/CarShareSystem/app/domain/error"
	domain_event "github.com/onion0904/CarShareSystem/app/domain/event"
	repo "github.com/onion0904/CarShareSystem/app/infrastructure/repository"
	"github.com/onion0904/CarShareSystem/app/middleware"
	"github.com/onion0904/CarShareSystem/app/presentation/graphql/graph/model"
	usecase_event "github.com/onion0904/CarShareSystem/app/usecase/event"
	usecase_eventRule "github.com/onion0904/CarShareSystem/app/usecase/eventRule"
	usecase_group "github.com/onion0904/CarShareSystem/app/usecase/group"
	usecase_item "github.com/onion0904/CarShareSystem/app/usecase/item"
	usecase_mail "github.com/onion0904/CarShareSystem/app/usecase/mail"
	usecase_user "github.com/onion0904/CarShareSystem/app/usecase/user"
	"github.com/onion0904/CarShareSystem/pkg/jwt"
	VerifiedCode "github.com/onion0904/CarShareSystem/pkg/verified_code"
	"golang.org/x/crypto/bcrypt"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	userRepo := repo.NewUserRepository(r.DB)
	update := usecase_user.NewUpdateUserUseCase(userRepo)
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	userID, _ := middleware.GetUserID(ctx)
	DTO := usecase_user.UpdateUseCaseDto{
		LastName:  input.LastName,
		FirstName: input.FirstName,
		Email:     input.Email,
	}
	user, err := update.Run(ctx, userID, DTO)
	if err != nil {
		return nil, err
	}
	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}
	return &nuser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context) (bool, error) {
	userRepo := repo.NewUserRepository(r.DB)
	delete := usecase_user.NewDeleteUseCase(userRepo)
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	userID, _ := middleware.GetUserID(ctx)
	err := delete.Run(ctx, userID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.CreateGroupInput) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	create := usecase_group.NewSaveUseCase(groupRepo)

	DTO := usecase_group.SaveUseCaseDto{
		Name: input.Name,
	}

	group, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, input model.UpdateGroupInput) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	update := usecase_group.NewUpdateUseCase(groupRepo)
	DTO := usecase_group.UpdateUseCaseDto{
		Name: *input.Name,
	}
	group, err := update.Run(ctx, id, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (bool, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	delete := usecase_group.NewDeleteUseCase(groupRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// AddUserToGroup is the resolver for the addUserToGroup field.
func (r *mutationResolver) AddUserToGroup(ctx context.Context, groupID string, userID string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	addUser := usecase_group.NewAddUserToGroupUseCase(groupRepo)
	DTO := usecase_group.AddUserToGroupUseCaseDto{
		UserID:  userID,
		GroupID: groupID,
	}
	group, err := addUser.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// RemoveUserFromGroup is the resolver for the removeUserFromGroup field.
func (r *mutationResolver) RemoveUserFromGroup(ctx context.Context, groupID string, userID string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	removeUser := usecase_group.NewRemoveUserToGroupUseCase(groupRepo)
	DTO := usecase_group.RemoveUserFromGroupUseCaseDto{
		UserID:  userID,
		GroupID: groupID,
	}
	group, err := removeUser.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// AddEventToGroup is the resolver for the addEventToGroup field.
func (r *mutationResolver) AddEventToGroup(ctx context.Context, groupID string, eventID string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	addEvent := usecase_group.NewAddEventToGroupUseCase(groupRepo)
	DTO := usecase_group.AddEventToGroupUseCaseDto{
		EventID: eventID,
		GroupID: groupID,
	}
	group, err := addEvent.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// GenerateGroupInviteLink is the resolver for the generateGroupInviteLink field.
func (r *mutationResolver) GenerateGroupInviteLink(ctx context.Context, groupID string) (string, error) {
	inviteService := usecase_group.NewGroupInviteService(repo.NewGroupRepository(r.DB), r.BaseURL)
	return inviteService.GenerateInviteLink(ctx, groupID)
}

// GenerateGroupInviteQRCode is the resolver for the generateGroupInviteQRCode field.
func (r *mutationResolver) GenerateGroupInviteQRCode(ctx context.Context, groupID string) (string, error) {
	inviteService := usecase_group.NewGroupInviteService(repo.NewGroupRepository(r.DB), r.BaseURL)
	return inviteService.GenerateQRCode(ctx, groupID)
}

// AcceptGroupInvitation is the resolver for the acceptGroupInvitation field.
func (r *mutationResolver) AcceptGroupInvitation(ctx context.Context, token string) (*model.Group, error) {
	// 自身のUserIDを取得
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, errDomain.NewError("認証されていません")
	}

	// 招待トークンを検証
	cfg := config.GetConfig()
	claims, err := jwt.ParseInviteJWT(token, []byte(cfg.JWT.Secret))
	if err != nil {
		return nil, errDomain.NewError("無効な招待トークンです")
	}

	// ユーザーをグループに追加するユースケースを呼び出す
	addUserToGroupUC := usecase_group.NewAddUserToGroupUseCase(repo.NewGroupRepository(r.DB))
	dto := usecase_group.AddUserToGroupUseCaseDto{
		UserID:  userID,
		GroupID: claims.GroupID,
	}

	group, err := addUserToGroupUC.Run(ctx, dto)
	if err != nil {
		return nil, err
	}

	// 結果をGraphQLモデルに変換して返す
	return &model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	create := usecase_event.NewEventUseCase(domain_event.NewEventDomainService(eventRepo))
	DTO := usecase_event.AddEventUseCaseDTO{
		UsersID:     input.UserID,
		Together:    input.Together,
		Description: input.Description,
		Year:        input.Year,
		Month:       input.Month,
		Day:         input.Day,
		Important:   input.Important,
	}
	event, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	nevent := model.Event{
		ID:          event.ID(),
		UserID:      event.UserID(),
		Together:    event.Together(),
		Description: event.Description(),
		Year:        event.Year(),
		Month:       event.Month(),
		Day:         event.Day(),
		Date:        event.Date(),
		CreatedAt:   event.CreatedAt(),
		UpdatedAt:   event.UpdatedAt(),
		StartDate:   event.StartDate(),
		EndDate:     event.EndDate(),
		Important:   event.Important(),
	}
	return &nevent, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (bool, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	delete := usecase_event.NewDeleteUseCase(eventRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	create := usecase_item.NewSaveItemUseCase(itemRepo)
	DTO := usecase_item.SaveUseCaseDto{
		Name:    input.Name,
		GroupID: input.GroupID,
	}
	item, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	nitem := model.Item{
		ID:      item.ID,
		Name:    item.Name,
		GroupID: item.GroupID,
	}
	return &nitem, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id string) (bool, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	delete := usecase_item.NewDeleteUseCase(itemRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpsertEventRule is the resolver for the UpsertEventRule field.
func (r *mutationResolver) UpsertEventRule(ctx context.Context, input model.UpsertEventRuleInput) (bool, error) {
	eventRuleRepo := repo.NewEventRuleRepository(r.DB)
	create := usecase_eventRule.NewUpsertUseCase(eventRuleRepo)
	DTO := usecase_eventRule.UpsertUseCaseDto{
		UserID:         input.UserID,
		ItemID:         input.ItemID,
		NormalLimit:    input.NormalLimit,
		ImportantLimit: input.ImportantLimit,
	}
	err := create.Run(ctx, DTO)
	if err != nil {
		return false, err
	}
	return true, nil
}

// SendVerificationCode is the resolver for the sendVerificationCode field.
func (r *mutationResolver) SendVerificationCode(ctx context.Context, email string) (bool, error) {
	if email == "" {
		return false, errDomain.NewError("メールアドレスが必要です")
	}

	// 認証コードの生成
	vcode, err := VerifiedCode.GenerateVerificationCode()
	if err != nil {
		log.Printf("Error generating verification code: %v", err)
		return false, errDomain.NewError("認証コードの生成に失敗しました")
	}

	// 認証コードを保存
	r.EmailUseCase.CodeMutex.Lock()
	r.EmailUseCase.VerificationCodes[email] = vcode
	r.EmailUseCase.CodeMutex.Unlock()
	// メール送信

	DTO := usecase_mail.SendEmailUseCaseDto{
		Email: email,
		Code:  vcode,
	}
	r.EmailUseCase.Run(ctx, DTO)
	return true, nil
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.CreateUserInput, vcode string) (*model.AuthUserResponse, error) {
	c := config.GetConfig()
	secret := c.JWT.Secret
	if secret == "" {
		log.Printf("JWT secret key is not set")
		return nil, errDomain.NewError("JWT secret key is not set")
	}
	jwtSecret := []byte(secret)

	if input.Email == "" || input.Password == "" || vcode == "" {
		return nil, errDomain.NewError("Email or Password or verified code is not set")
	}
	userRepo := repo.NewUserRepository(r.DB)
	exist := usecase_user.NewCheckExistUserUseCase(userRepo)
	existed, err := exist.Run(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	if existed {
		return nil, errDomain.NewError("User is already registered")
	}

	r.EmailUseCase.CodeMutex.Lock()
	expectedCode, exists := r.EmailUseCase.VerificationCodes[input.Email]
	r.EmailUseCase.CodeMutex.Unlock()

	if !exists {
		return nil, errDomain.NewError("verified code is not found")
	}

	if expectedCode != vcode {
		return nil, errDomain.NewError("Invalid verified code")
	}

	r.EmailUseCase.CodeMutex.Lock()
	delete(r.EmailUseCase.VerificationCodes, input.Email)
	r.EmailUseCase.CodeMutex.Unlock()

	create := usecase_user.NewSaveUserUseCase(userRepo)

	DTO := usecase_user.SaveUseCaseDto{
		LastName:  input.LastName,
		FirstName: input.FirstName,
		Email:     input.Email,
		Password:  input.Password,
	}

	user, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}

	customClaim := jwt.NewCustomClaims(user.Email, user.ID)
	token := jwt.CreateToken(customClaim)
	tokenString, err := token.SignedString([]byte(jwtSecret))
	if err != nil {
		return nil, err
	}
	return &model.AuthUserResponse{
		Token: tokenString,
		User:  &nuser,
	}, nil
}

// Signin is the resolver for the signin field.
func (r *mutationResolver) Signin(ctx context.Context, email string, password string) (*model.AuthUserResponse, error) {
	c := config.GetConfig()
	secret := c.JWT.Secret
	if secret == "" {
		log.Printf("JWT secret key is not set")
		return nil, errDomain.NewError("JWT secret key is not set")
	}
	jwtSecret := []byte(secret)

	if email == "" || password == "" {
		return nil, errDomain.NewError("Email or Password or verified code is not set")
	}
	userRepo := repo.NewUserRepository(r.DB)

	exist := usecase_user.NewCheckExistUserUseCase(userRepo)
	exists, err := exist.Run(ctx, email, password)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errDomain.NewError("User is not found")
	}

	find := usecase_user.NewFindUserByEmailPasswordUseCase(userRepo)
	user, err := find.Run(ctx, email)
	if err != nil {
		return nil, err
	}

	//hashパスワードと平文パスワードで比較
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errDomain.NewError("invalid credentials")
	}

	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}

	customClaim := jwt.NewCustomClaims(email, user.ID)
	token := jwt.CreateToken(customClaim)
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		return nil, err
	}
	return &model.AuthUserResponse{
		Token: tokenString,
		User:  &nuser,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*model.User, error) {
	userRepo := repo.NewUserRepository(r.DB)
	find := usecase_user.NewFindUserUseCase(userRepo)
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		fmt.Println("UserID:", userID)
		return nil, errDomain.NewError("not authenticate")
	}
	user, err := find.Run(ctx, userID)
	if err != nil {
		return nil, err
	}
	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}
	return &nuser, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	find := usecase_group.NewFindGroupUseCase(groupRepo)
	group, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID,
		Name:      group.Name,
		CreatedAt: group.CreatedAt,
		UpdatedAt: group.UpdatedAt,
		UserIDs:   group.UserIDs,
		EventIDs:  group.EventIDs,
	}
	return &ngroup, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	find := usecase_event.NewFindEventUseCase(eventRepo)
	event, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	nevent := model.Event{
		ID:          event.ID,
		UserID:      event.UserID,
		Together:    event.Together,
		Description: event.Description,
		Year:        event.Year,
		Month:       event.Month,
		Day:         event.Day,
		Date:        event.Date,
		CreatedAt:   event.CreatedAt,
		UpdatedAt:   event.UpdatedAt,
		StartDate:   event.StartDate,
		EndDate:     event.EndDate,
		Important:   event.Important,
	}
	return &nevent, nil
}

// EventsByMonth is the resolver for the eventsByMonth field.
func (r *queryResolver) EventsByMonth(ctx context.Context, input model.MonthlyEventInput) ([]string, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	find := usecase_event.NewFindMonthEventUseCase(eventRepo)
	events, err := find.Run(ctx, input.Year, input.Month)
	if err != nil {
		return nil, err
	}
	return events.EventIDs, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	find := usecase_item.NewFindItemByIDUseCase(itemRepo)
	item, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	nitem := model.Item{
		ID:      item.ID,
		Name:    item.Name,
		GroupID: item.GroupID,
	}
	return &nitem, nil
}

// ItemsBygroupID is the resolver for the itemsBygroupID field.
func (r *queryResolver) ItemsBygroupID(ctx context.Context, groupID string) ([]*model.Item, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	find := usecase_item.NewFindItemByGroupIDUseCase(itemRepo)
	items, err := find.Run(ctx, groupID)
	if err != nil {
		return nil, err
	}
	var nitems []*model.Item
	for _, item := range *items {
		nitems = append(nitems,
			&model.Item{
				ID:      item.ID,
				Name:    item.Name,
				GroupID: item.GroupID,
			})
	}
	return nitems, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
