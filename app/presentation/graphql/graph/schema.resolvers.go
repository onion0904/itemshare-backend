package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"

	"github.com/onion0904/CarShareSystem/app/config"
	errDomain "github.com/onion0904/CarShareSystem/app/domain/error"
	domain_event "github.com/onion0904/CarShareSystem/app/domain/event"
	repo "github.com/onion0904/CarShareSystem/app/infrastructure/repository"
	"github.com/onion0904/CarShareSystem/app/middleware"
	"github.com/onion0904/CarShareSystem/app/presentation/graphql/graph/model"
	usecase_event "github.com/onion0904/CarShareSystem/app/usecase/event"
	usecase_eventRule "github.com/onion0904/CarShareSystem/app/usecase/eventRule"
	usecase_group "github.com/onion0904/CarShareSystem/app/usecase/group"
	usecase_item "github.com/onion0904/CarShareSystem/app/usecase/item"
	usecase_mail "github.com/onion0904/CarShareSystem/app/usecase/mail"
	usecase_user "github.com/onion0904/CarShareSystem/app/usecase/user"
	"github.com/onion0904/CarShareSystem/pkg/jwt"
	VerifiedCode "github.com/onion0904/CarShareSystem/pkg/verified_code"
	"golang.org/x/crypto/bcrypt"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	userRepo := repo.NewUserRepository(r.DB)
	update := usecase_user.NewUpdateUserUseCase(userRepo)
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	userID, _ := middleware.GetUserID(ctx)
	DTO := usecase_user.UpdateUseCaseDto{
		LastName:  input.LastName,
		FirstName: input.FirstName,
	}
	user, err := update.Run(ctx, userID, DTO)
	if err != nil {
		return nil, err
	}
	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}
	return &nuser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context) (bool, error) {
	userRepo := repo.NewUserRepository(r.DB)
	delete := usecase_user.NewDeleteUseCase(userRepo)
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	userID, _ := middleware.GetUserID(ctx)
	err := delete.Run(ctx, userID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, name string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	create := usecase_group.NewSaveUseCase(groupRepo)
	autg := usecase_group.NewAddUserToGroupUseCase(groupRepo)

	var userIDs []string
	userID, _ := middleware.GetUserID(ctx)
	userIDs = append(userIDs, userID)
	DTO := usecase_group.SaveUseCaseDto{
		Name:    name,
		UsersID: userIDs,
	}

	group, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}

	autgDTO := usecase_group.AddUserToGroupUseCaseDto{
		UserID:  userID,
		GroupID: group.ID(),
	}
	_, err = autg.Run(ctx, autgDTO)
	if err != nil {
		return nil, err
	}
	return &ngroup, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, input model.UpdateGroupInput) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	update := usecase_group.NewUpdateUseCase(groupRepo)
	DTO := usecase_group.UpdateUseCaseDto{
		Name: *input.Name,
	}
	group, err := update.Run(ctx, id, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (bool, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	delete := usecase_group.NewDeleteUseCase(groupRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// RemoveUserFromGroup is the resolver for the removeUserFromGroup field.
func (r *mutationResolver) RemoveUserFromGroup(ctx context.Context, groupID string, userID string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	removeUser := usecase_group.NewRemoveUserToGroupUseCase(groupRepo)
	DTO := usecase_group.RemoveUserFromGroupUseCaseDto{
		UserID:  userID,
		GroupID: groupID,
	}
	group, err := removeUser.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}
	return &ngroup, nil
}

// GenerateGroupInviteLink is the resolver for the generateGroupInviteLink field.
func (r *mutationResolver) GenerateGroupInviteLink(ctx context.Context, groupID string) (string, error) {
	inviteService := usecase_group.NewGroupInviteService(repo.NewGroupRepository(r.DB), r.BaseURL)
	return inviteService.GenerateInviteLink(ctx, groupID)
}

// GenerateGroupInviteQRCode is the resolver for the generateGroupInviteQRCode field.
func (r *mutationResolver) GenerateGroupInviteQRCode(ctx context.Context, groupID string) (string, error) {
	inviteService := usecase_group.NewGroupInviteService(repo.NewGroupRepository(r.DB), r.BaseURL)
	return inviteService.GenerateQRCode(ctx, groupID)
}

// AcceptGroupInvitation is the resolver for the acceptGroupInvitation field.
func (r *mutationResolver) AcceptGroupInvitation(ctx context.Context, token string) (*model.Group, error) {
	// 自身のUserIDを取得
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, errDomain.NewError("認証されていません")
	}

	// 招待トークンを検証
	cfg := config.GetConfig()
	claims, err := jwt.ParseInviteJWT(token, []byte(cfg.JWT.Secret))
	if err != nil {
		return nil, errDomain.NewError("無効な招待トークンです")
	}

	// ユーザーをグループに追加するユースケースを呼び出す
	addUserToGroupUC := usecase_group.NewAddUserToGroupUseCase(repo.NewGroupRepository(r.DB))
	dto := usecase_group.AddUserToGroupUseCaseDto{
		UserID:  userID,
		GroupID: claims.GroupID,
	}

	group, err := addUserToGroupUC.Run(ctx, dto)
	if err != nil {
		return nil, err
	}

	findItemsByGroupIDUC := usecase_item.NewFindItemByGroupIDUseCase(repo.NewItemRepository(r.DB))
	items, err := findItemsByGroupIDUC.Run(ctx, claims.GroupID)
	if err != nil {
		return nil, err
	}

	// eventRuleのデフォルト値の追加
	upsertEventRuleUC := usecase_eventRule.NewUpsertUseCase(repo.NewEventRuleRepository(r.DB))
	for _, item := range items {
		err := upsertEventRuleUC.Run(ctx, usecase_eventRule.UpsertUseCaseDto{
			UserID:         userID,
			ItemID:         item.ID,
			NormalLimit:    7,
			ImportantLimit: 0,
		})
		if err != nil {
			return nil, err
		}
	}

	// 結果をGraphQLモデルに変換して返す
	return &model.Group{
		ID:        group.ID(),
		Name:      group.Name(),
		CreatedAt: group.CreatedAt(),
		UpdatedAt: group.UpdatedAt(),
		UserIDs:   group.UserIDs(),
		EventIDs:  group.EventIDs(),
	}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput, groupID string) (*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	eventRuleRepo := repo.NewEventRuleRepository(r.DB)
	userID, _ := middleware.GetUserID(ctx)
	create := usecase_event.NewEventUseCase(domain_event.NewEventDomainService(eventRepo, eventRuleRepo))
	AddEventUseCaseDTO := usecase_event.AddEventUseCaseDTO{
		UsersID:     userID,
		ItemID:      input.ItemID,
		Together:    input.Together,
		Description: input.Description,
		Year:        input.Year,
		Month:       input.Month,
		Day:         input.Day,
		Important:   input.Important,
	}
	event, err := create.Run(ctx, AddEventUseCaseDTO, groupID)
	if err != nil {
		return nil, err
	}

	groupRepo := repo.NewGroupRepository(r.DB)
	addEvent := usecase_group.NewAddEventToGroupUseCase(groupRepo)
	AddEventToGroupUseCaseDto := usecase_group.AddEventToGroupUseCaseDto{
		EventID: event.ID(),
		GroupID: groupID,
	}
	_, err = addEvent.Run(ctx, AddEventToGroupUseCaseDto)
	if err != nil {
		return nil, err
	}

	nevent := model.Event{
		ID:          event.ID(),
		UserID:      event.UserID(),
		Together:    event.Together(),
		Description: event.Description(),
		Year:        event.Year(),
		Month:       event.Month(),
		Day:         event.Day(),
		Date:        event.Date(),
		CreatedAt:   event.CreatedAt(),
		UpdatedAt:   event.UpdatedAt(),
		StartDate:   event.StartDate(),
		EndDate:     event.EndDate(),
		Important:   event.Important(),
	}
	return &nevent, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (bool, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	delete := usecase_event.NewDeleteUseCase(eventRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	// 1. アイテムを作成
	itemRepo := repo.NewItemRepository(r.DB)
	create := usecase_item.NewSaveItemUseCase(itemRepo)
	DTO := usecase_item.SaveUseCaseDto{
		Name:    input.Name,
		GroupID: input.GroupID,
	}
	item, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}

	// 2. グループ情報を取得
	groupRepo := repo.NewGroupRepository(r.DB)
	findGroupUC := usecase_group.NewFindGroupUseCase(groupRepo)
	group, err := findGroupUC.Run(ctx, input.GroupID)
	if err != nil {
		return nil, fmt.Errorf("failed to find group: %w", err)
	}

	// 3. グループに所属する全ユーザーのイベントルールを作成
	eventRuleRepo := repo.NewEventRuleRepository(r.DB)
	upsertEventRuleUC := usecase_eventRule.NewUpsertUseCase(eventRuleRepo)

	log.Printf("Creating event rules for users: %v", group.UserIDs) // デバッグログ

	for _, userID := range group.UserIDs {
		if userID == "" {
			continue // 空のユーザーIDをスキップ
		}

		err := upsertEventRuleUC.Run(ctx, usecase_eventRule.UpsertUseCaseDto{
			UserID:         userID,
			ItemID:         item.ID,
			NormalLimit:    7, // デフォルト値
			ImportantLimit: 0, // デフォルト値
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create event rule for user %s: %w", userID, err)
		}
	}

	return &model.Item{
		ID:      item.ID,
		Name:    item.Name,
		GroupID: item.GroupID,
	}, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id string) (bool, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	delete := usecase_item.NewDeleteUseCase(itemRepo)
	err := delete.Run(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpsertEventRule is the resolver for the UpsertEventRule field.
func (r *mutationResolver) UpsertEventRule(ctx context.Context, input model.UpsertEventRuleInput) (bool, error) {
	eventRuleRepo := repo.NewEventRuleRepository(r.DB)
	create := usecase_eventRule.NewUpsertUseCase(eventRuleRepo)
	DTO := usecase_eventRule.UpsertUseCaseDto{
		UserID:         input.UserID,
		ItemID:         input.ItemID,
		NormalLimit:    input.NormalLimit,
		ImportantLimit: input.ImportantLimit,
	}
	err := create.Run(ctx, DTO)
	if err != nil {
		return false, err
	}
	return true, nil
}

// SendVerificationCode is the resolver for the sendVerificationCode field.
func (r *mutationResolver) SendVerificationCode(ctx context.Context, email string) (bool, error) {
	if email == "" {
		return false, errDomain.NewError("メールアドレスが必要です")
	}

	// 認証コードの生成
	vcode, err := VerifiedCode.GenerateVerificationCode()
	if err != nil {
		log.Printf("Error generating verification code: %v", err)
		return false, errDomain.NewError("認証コードの生成に失敗しました")
	}

	// 認証コードを保存
	r.EmailUseCase.CodeMutex.Lock()
	r.EmailUseCase.VerificationCodes[email] = vcode
	r.EmailUseCase.CodeMutex.Unlock()
	// メール送信

	DTO := usecase_mail.SendEmailUseCaseDto{
		Email: email,
		Code:  vcode,
	}
	r.EmailUseCase.Run(ctx, DTO)
	return true, nil
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.CreateUserInput, vcode string) (*model.AuthUserResponse, error) {
	c := config.GetConfig()
	secret := c.JWT.Secret
	if secret == "" {
		log.Printf("JWT secret key is not set")
		return nil, errDomain.NewError("JWT secret key is not set")
	}
	jwtSecret := []byte(secret)

	if input.Email == "" || input.Password == "" || vcode == "" {
		return nil, errDomain.NewError("Email or Password or verified code is not set")
	}
	userRepo := repo.NewUserRepository(r.DB)
	exist := usecase_user.NewCheckExistUserUseCase(userRepo)
	existed, err := exist.Run(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	if existed {
		return nil, errDomain.NewError("User is already registered")
	}

	r.EmailUseCase.CodeMutex.Lock()
	expectedCode, exists := r.EmailUseCase.VerificationCodes[input.Email]
	r.EmailUseCase.CodeMutex.Unlock()

	if !exists {
		return nil, errDomain.NewError("verified code is not found")
	}

	if expectedCode != vcode {
		return nil, errDomain.NewError("Invalid verified code")
	}

	r.EmailUseCase.CodeMutex.Lock()
	delete(r.EmailUseCase.VerificationCodes, input.Email)
	r.EmailUseCase.CodeMutex.Unlock()

	create := usecase_user.NewSaveUserUseCase(userRepo)

	DTO := usecase_user.SaveUseCaseDto{
		LastName:  input.LastName,
		FirstName: input.FirstName,
		Email:     input.Email,
		Password:  input.Password,
	}

	user, err := create.Run(ctx, DTO)
	if err != nil {
		return nil, err
	}
	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}

	customClaim := jwt.NewCustomClaims(user.Email, user.ID)
	token := jwt.CreateToken(customClaim)
	tokenString, err := token.SignedString([]byte(jwtSecret))
	if err != nil {
		return nil, err
	}

	return &model.AuthUserResponse{
		Token: tokenString,
		User:  &nuser,
	}, nil
}

// Signin is the resolver for the signin field.
func (r *mutationResolver) Signin(ctx context.Context, email string, password string) (*model.AuthUserResponse, error) {
	c := config.GetConfig()
	secret := c.JWT.Secret
	if secret == "" {
		log.Printf("JWT secret key is not set")
		return nil, errDomain.NewError("JWT secret key is not set")
	}
	jwtSecret := []byte(secret)

	if email == "" || password == "" {
		return nil, errDomain.NewError("Email or Password or verified code is not set")
	}
	userRepo := repo.NewUserRepository(r.DB)

	exist := usecase_user.NewCheckExistUserUseCase(userRepo)
	exists, err := exist.Run(ctx, email, password)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errDomain.NewError("User is not found")
	}

	find := usecase_user.NewFindUserByEmailPasswordUseCase(userRepo)
	user, err := find.Run(ctx, email)
	if err != nil {
		return nil, err
	}

	//hashパスワードと平文パスワードで比較
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errDomain.NewError("invalid credentials")
	}

	nuser := model.User{
		ID:        user.ID,
		LastName:  user.LastName,
		FirstName: user.FirstName,
		Email:     user.Email,
		Password:  user.Password,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
		GroupIDs:  user.GroupIDs,
		EventIDs:  user.EventIDs,
	}

	customClaim := jwt.NewCustomClaims(email, user.ID)
	token := jwt.CreateToken(customClaim)
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		return nil, err
	}
	return &model.AuthUserResponse{
		Token: tokenString,
		User:  &nuser,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string) (*model.User, error) {
	userRepo := repo.NewUserRepository(r.DB)
	find := usecase_user.NewFindUserUseCase(userRepo)
	var user *usecase_user.FindUserUseCaseDto
	var err error
	//ctx から取った userID を使うことで 「なりすまし」を防ぐ
	if id != nil {
		// 本人じゃない時
		user, err = find.Run(ctx, *id)
		if err != nil {
			return nil, err
		}
		return &model.User{
			ID:        user.ID,
			LastName:  user.LastName,
			FirstName: user.FirstName,
			Email:     user.Email,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
		}, nil
	}

	userID, ok := middleware.GetUserID(ctx)
	if ok {
		// 本人の時
		user, err = find.Run(ctx, userID)
		if err != nil {
			return nil, err
		}
		return &model.User{
			ID:        user.ID,
			LastName:  user.LastName,
			FirstName: user.FirstName,
			Email:     user.Email,
			CreatedAt: user.CreatedAt,
			UpdatedAt: user.UpdatedAt,
			GroupIDs:  user.GroupIDs,
			EventIDs:  user.EventIDs,
		}, nil
	}

	return nil, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	groupRepo := repo.NewGroupRepository(r.DB)
	find := usecase_group.NewFindGroupUseCase(groupRepo)
	group, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	ngroup := model.Group{
		ID:        group.ID,
		Name:      group.Name,
		CreatedAt: group.CreatedAt,
		UpdatedAt: group.UpdatedAt,
		UserIDs:   group.UserIDs,
		EventIDs:  group.EventIDs,
	}
	return &ngroup, nil
}

// GroupsByUserID is the resolver for the groupsByUserID field.
func (r *queryResolver) GroupsByUserID(ctx context.Context) ([]*model.Group, error) {
	userID, _ := middleware.GetUserID(ctx)
	groupRepo := repo.NewGroupRepository(r.DB)
	find := usecase_group.NewFindGroupsByUserIDUseCase(groupRepo)
	groups, err := find.Run(ctx, userID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Group, 0, len(groups))
	for _, group := range groups {
		if group != nil {
			result = append(result, &model.Group{
				ID:        group.ID,
				Name:      group.Name,
				CreatedAt: group.CreatedAt,
				UpdatedAt: group.UpdatedAt,
				UserIDs:   group.UserIDs,
				EventIDs:  group.EventIDs,
			})
		}
	}
	return result, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	find := usecase_event.NewFindEventUseCase(eventRepo)
	event, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	nevent := model.Event{
		ID:          event.ID,
		UserID:      event.UserID,
		Together:    event.Together,
		Description: event.Description,
		Year:        event.Year,
		Month:       event.Month,
		Day:         event.Day,
		Date:        event.Date,
		CreatedAt:   event.CreatedAt,
		UpdatedAt:   event.UpdatedAt,
		StartDate:   event.StartDate,
		EndDate:     event.EndDate,
		Important:   event.Important,
	}
	return &nevent, nil
}

// EventsByMonth is the resolver for the eventsByMonth field.
func (r *queryResolver) EventsByMonth(ctx context.Context, input model.MonthlyEventInput, groupID string) ([]*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	find := usecase_event.NewFindMonthEventsOfGroupUseCase(eventRepo)
	events, err := find.Run(ctx, input.Year, input.Month, groupID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Event, 0, len(events))
	for _, event := range events {
		result = append(result, &model.Event{
			ID:          event.ID,
			UserID:      event.UserID,
			ItemID:      event.ItemID,
			Together:    event.Together,
			Description: event.Description,
			Year:        event.Year,
			Month:       event.Month,
			Day:         event.Day,
			Date:        event.Date,
			CreatedAt:   event.CreatedAt,
			UpdatedAt:   event.UpdatedAt,
			StartDate:   event.StartDate,
			EndDate:     event.EndDate,
			Important:   event.Important,
		})
	}
	return result, nil
}

// EventsByDay is the resolver for the eventsByDay field.
func (r *queryResolver) EventsByDay(ctx context.Context, input model.DailyEventInput, groupID string) ([]*model.Event, error) {
	eventRepo := repo.NewEventRepository(r.DB)
	find := usecase_event.NewFindDayEventsOfGroupUseCase(eventRepo)
	events, err := find.Run(ctx, input.Year, input.Month, input.Day, groupID)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Event, 0, len(events))
	for _, event := range events {
		result = append(result, &model.Event{
			ID:          event.ID,
			UserID:      event.UserID,
			ItemID:      event.ItemID,
			Together:    event.Together,
			Description: event.Description,
			Year:        event.Year,
			Month:       event.Month,
			Day:         event.Day,
			Date:        event.Date,
			CreatedAt:   event.CreatedAt,
			UpdatedAt:   event.UpdatedAt,
			StartDate:   event.StartDate,
			EndDate:     event.EndDate,
			Important:   event.Important,
		})
	}

	return result, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	find := usecase_item.NewFindItemByIDUseCase(itemRepo)
	item, err := find.Run(ctx, id)
	if err != nil {
		return nil, err
	}
	nitem := model.Item{
		ID:      item.ID,
		Name:    item.Name,
		GroupID: item.GroupID,
	}
	return &nitem, nil
}

// ItemsBygroupID is the resolver for the itemsBygroupID field.
func (r *queryResolver) ItemsBygroupID(ctx context.Context, groupID string) ([]*model.Item, error) {
	itemRepo := repo.NewItemRepository(r.DB)
	find := usecase_item.NewFindItemByGroupIDUseCase(itemRepo)
	items, err := find.Run(ctx, groupID)
	if err != nil {
		return nil, err
	}
	var nitems []*model.Item
	for _, item := range items {
		nitems = append(nitems,
			&model.Item{
				ID:      item.ID,
				Name:    item.Name,
				GroupID: item.GroupID,
			})
	}
	return nitems, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
